#!/usr/bin/env bash
set -euo pipefail

OTTO_ROOT="${OTTO_ROOT:-$HOME/.local/share/otto}"
RELEASES_DIR="${OTTO_ROOT}/releases"
CURRENT_LINK="${OTTO_ROOT}/current"
INSTALL_META="${OTTO_ROOT}/install.env"
SECRETS_DIR="${OTTO_ROOT}/secrets"
TELEGRAM_ENV_FILE="${SECRETS_DIR}/telegram.env"
RUNTIME_ENV_FILE="${SECRETS_DIR}/runtime.env"
BIN_DIR="${OTTO_BIN_DIR:-$HOME/.local/bin}"
SERVICE_NAME="otto"
PLIST_LABEL="com.otto.assistant"
PLIST_FILE="${HOME}/Library/LaunchAgents/${PLIST_LABEL}.plist"
CONTROL_PLANE_SERVICE_NAME="otto-control-plane"
CONTROL_PLANE_PLIST_LABEL="com.otto.assistant.control-plane"
CONTROL_PLANE_PLIST_FILE="${HOME}/Library/LaunchAgents/${CONTROL_PLANE_PLIST_LABEL}.plist"
DEFAULT_CONTROL_PLANE_HOST="0.0.0.0"
DEFAULT_CONTROL_PLANE_PORT="4173"
DEFAULT_REPO="MarcoMuellner/otto"
OTTO_HOME=""
TASK_CONFIG_DIR=""
TASK_PROFILE_DIR=""
STATE_DB_PATH=""

BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[0;33m'
RED=$'\033[0;31m'
NC=$'\033[0m'

info() { echo "${BLUE}[ottoctl]${NC} $*"; }
success() { echo "${GREEN}[ottoctl]${NC} $*"; }
warn() { echo "${YELLOW}[ottoctl]${NC} $*"; }
error() { echo "${RED}[ottoctl]${NC} $*" >&2; }

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    error "Required command '$1' not found"
    exit 1
  fi
}

detect_platform() {
  case "$(uname -s)" in
    Linux) echo "linux" ;;
    Darwin) echo "macos" ;;
    *)
      error "Unsupported platform: $(uname -s)"
      exit 1
      ;;
  esac
}

load_install_meta() {
  if [[ -f "${INSTALL_META}" ]]; then
    # shellcheck disable=SC1090
    source "${INSTALL_META}"
  fi
}

resolve_otto_home() {
  local config_path="${HOME}/.config/otto/config.jsonc"

  if [[ -f "${config_path}" ]]; then
    local resolved_home
    resolved_home="$(node -e 'const fs=require("node:fs"); const p=process.argv[1]; try {const raw=fs.readFileSync(p,"utf8"); const parsed=JSON.parse(raw); if (parsed && typeof parsed.ottoHome === "string" && parsed.ottoHome.length > 0) { process.stdout.write(parsed.ottoHome); process.exit(0);} } catch {} process.exit(1)' "${config_path}" 2>/dev/null || true)"
    if [[ -n "${resolved_home}" ]]; then
      echo "${resolved_home}"
      return
    fi
  fi

  echo "${HOME}/.otto"
}

load_telegram_env() {
  if [[ -f "${TELEGRAM_ENV_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${TELEGRAM_ENV_FILE}"
  fi
}

load_runtime_env() {
  if [[ -f "${RUNTIME_ENV_FILE}" ]]; then
    set -a
    # shellcheck disable=SC1090
    source "${RUNTIME_ENV_FILE}"
    set +a
  fi
}

has_telegram_credentials() {
  [[ -n "${TELEGRAM_BOT_TOKEN:-}" ]] && [[ -n "${TELEGRAM_ALLOWED_USER_ID:-}" ]]
}

is_positive_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] && [[ "$1" -ge 1 ]]
}

is_valid_env_key() {
  [[ "$1" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]
}

sql_escape() {
  local value="$1"
  value="${value//\'/\'\'}"
  printf '%s' "${value}"
}

xml_escape() {
  local value="$1"
  value="${value//&/&amp;}"
  value="${value//</&lt;}"
  value="${value//>/&gt;}"
  value="${value//\"/&quot;}"
  value="${value//\'/&apos;}"
  printf '%s' "${value}"
}

resolve_control_plane_host() {
  local host="${OTTO_CONTROL_PLANE_HOST:-${DEFAULT_CONTROL_PLANE_HOST}}"
  host="${host//[[:space:]]/}"

  if [[ -z "${host}" ]]; then
    echo "${DEFAULT_CONTROL_PLANE_HOST}"
    return
  fi

  echo "${host}"
}

resolve_control_plane_port() {
  local port="${OTTO_CONTROL_PLANE_PORT:-${DEFAULT_CONTROL_PLANE_PORT}}"
  port="${port//[[:space:]]/}"

  if [[ -z "${port}" ]]; then
    echo "${DEFAULT_CONTROL_PLANE_PORT}"
    return
  fi

  if [[ ! "${port}" =~ ^[0-9]+$ ]] || [[ "${port}" -lt 1 ]] || [[ "${port}" -gt 65535 ]]; then
    warn "Invalid OTTO_CONTROL_PLANE_PORT '${port}', falling back to ${DEFAULT_CONTROL_PLANE_PORT}"
    echo "${DEFAULT_CONTROL_PLANE_PORT}"
    return
  fi

  echo "${port}"
}

prepend_path_entry() {
  local current_path="$1"
  local entry="$2"

  if [[ -z "${entry}" ]] || [[ ! -d "${entry}" ]]; then
    echo "${current_path}"
    return
  fi

  case ":${current_path}:" in
    *":${entry}:"*)
      echo "${current_path}"
      ;;
    *)
      if [[ -z "${current_path}" ]]; then
        echo "${entry}"
      else
        echo "${entry}:${current_path}"
      fi
      ;;
  esac
}

build_service_path() {
  local service_path="${PATH}"
  local node_dir
  node_dir="$(dirname "$(command -v node)")"
  service_path="$(prepend_path_entry "${service_path}" "${node_dir}")"
  service_path="$(prepend_path_entry "${service_path}" "${HOME}/.opencode/bin")"
  service_path="$(prepend_path_entry "${service_path}" "${HOME}/.local/bin")"

  echo "${service_path}"
}

control_plane_server_path() {
  echo "${CURRENT_LINK}/control-plane/build/server/index.js"
}

control_plane_serve_cli_path() {
  echo "${CURRENT_LINK}/control-plane/node_modules/@react-router/serve/dist/cli.js"
}

has_control_plane_release() {
  local server_path
  server_path="$(control_plane_server_path)"
  local serve_cli
  serve_cli="$(control_plane_serve_cli_path)"

  [[ -f "${server_path}" ]] && [[ -f "${serve_cli}" ]]
}

ensure_runtime_env_file() {
  mkdir -p "${SECRETS_DIR}"
  chmod 700 "${SECRETS_DIR}"
  touch "${RUNTIME_ENV_FILE}"
  chmod 600 "${RUNTIME_ENV_FILE}"
}

set_runtime_env_value() {
  local key="$1"
  local value="$2"

  ensure_runtime_env_file

  node -e '
const fs = require("node:fs")
const envPath = process.argv[1]
const key = process.argv[2]
const value = process.argv[3]

const lines = fs.existsSync(envPath)
  ? fs.readFileSync(envPath, "utf8").split(/\r?\n/)
  : []

const entries = new Map()

for (const rawLine of lines) {
  const line = rawLine.trim()
  if (!line || line.startsWith("#")) continue
  const idx = line.indexOf("=")
  if (idx <= 0) continue
  const entryKey = line.slice(0, idx).trim()
  const entryValue = line.slice(idx + 1).trim()
  if (!entryKey) continue
  entries.set(entryKey, entryValue)
}

entries.set(key, JSON.stringify(value))

const output = Array.from(entries.entries())
  .sort((a, b) => a[0].localeCompare(b[0]))
  .map(([k, v]) => `${k}=${v}`)
  .join("\n")

fs.writeFileSync(envPath, output.length > 0 ? `${output}\n` : "", "utf8")
' "${RUNTIME_ENV_FILE}" "${key}" "${value}"
}

unset_runtime_env_value() {
  local key="$1"

  ensure_runtime_env_file

  node -e '
const fs = require("node:fs")
const envPath = process.argv[1]
const key = process.argv[2]

const lines = fs.existsSync(envPath)
  ? fs.readFileSync(envPath, "utf8").split(/\r?\n/)
  : []

const entries = new Map()

for (const rawLine of lines) {
  const line = rawLine.trim()
  if (!line || line.startsWith("#")) continue
  const idx = line.indexOf("=")
  if (idx <= 0) continue
  const entryKey = line.slice(0, idx).trim()
  const entryValue = line.slice(idx + 1).trim()
  if (!entryKey) continue
  entries.set(entryKey, entryValue)
}

entries.delete(key)

const output = Array.from(entries.entries())
  .sort((a, b) => a[0].localeCompare(b[0]))
  .map(([k, v]) => `${k}=${v}`)
  .join("\n")

fs.writeFileSync(envPath, output.length > 0 ? `${output}\n` : "", "utf8")
' "${RUNTIME_ENV_FILE}" "${key}"
}

runtime_env_plist_entries() {
  if [[ ! -f "${RUNTIME_ENV_FILE}" ]]; then
    return
  fi

  local keys=()
  while IFS= read -r raw_line; do
    local line="${raw_line%%$'\r'}"
    line="${line#${line%%[![:space:]]*}}"
    [[ -z "${line}" || "${line}" == \#* ]] && continue
    local key="${line%%=*}"
    key="${key%%[[:space:]]*}"
    if [[ -n "${key}" ]] && is_valid_env_key "${key}"; then
      keys+=("${key}")
    fi
  done < "${RUNTIME_ENV_FILE}"

  if [[ ${#keys[@]} -eq 0 ]]; then
    return
  fi

  (
    set -a
    # shellcheck disable=SC1090
    source "${RUNTIME_ENV_FILE}"
    set +a

    local key
    for key in "${keys[@]}"; do
      local value="${!key-}"
      if [[ -n "${value}" ]]; then
        printf '    <key>%s</key>\n    <string>%s</string>\n' "$(xml_escape "${key}")" "$(xml_escape "${value}")"
      fi
    done
  )
}

persist_telegram_credentials() {
  mkdir -p "${SECRETS_DIR}"
  chmod 700 "${SECRETS_DIR}"

cat > "${TELEGRAM_ENV_FILE}" <<EOF
TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
TELEGRAM_ALLOWED_USER_ID=${TELEGRAM_ALLOWED_USER_ID}
EOF

  chmod 600 "${TELEGRAM_ENV_FILE}"
}

prompt_telegram_credentials() {
  if [[ ! -t 0 || ! -t 1 ]]; then
    warn "Telegram credentials missing and terminal is non-interactive; skipping setup"
    return 1
  fi

  while true; do
    info "Telegram credentials are required for automatic Telegram worker startup."
    read -r -p "Configure Telegram now? [Y/n]: " configure_now

    case "${configure_now:-Y}" in
      Y|y|"")
        break
        ;;
      N|n)
        warn "Skipping Telegram credential setup for now"
        return 1
        ;;
      *)
        warn "Please answer Y or n"
        ;;
    esac
  done

  while true; do
    read -r -s -p "TELEGRAM_BOT_TOKEN: " TELEGRAM_BOT_TOKEN
    echo
    read -r -p "TELEGRAM_ALLOWED_USER_ID: " TELEGRAM_ALLOWED_USER_ID

    if [[ -z "${TELEGRAM_BOT_TOKEN}" ]]; then
      warn "TELEGRAM_BOT_TOKEN cannot be empty"
      continue
    fi

    if [[ "${TELEGRAM_BOT_TOKEN}" =~ [[:space:]] ]]; then
      warn "TELEGRAM_BOT_TOKEN cannot contain whitespace"
      continue
    fi

    if ! is_positive_integer "${TELEGRAM_ALLOWED_USER_ID}"; then
      warn "TELEGRAM_ALLOWED_USER_ID must be an integer >= 1"
      continue
    fi

    persist_telegram_credentials
    success "Saved Telegram credentials to ${TELEGRAM_ENV_FILE}"
    return 0
  done
}

ensure_telegram_credentials() {
  load_telegram_env

  if has_telegram_credentials; then
    persist_telegram_credentials
    info "Using existing Telegram credentials"
    return 0
  fi

  if prompt_telegram_credentials; then
    return 0
  fi

  return 1
}

resolve_otto_config_path() {
  echo "${HOME}/.config/otto/config.jsonc"
}

update_telegram_voice_settings() {
  local enabled="$1"
  local command_value="$2"
  local provider_value="${3:-worker}"

  local config_path
  config_path="$(resolve_otto_config_path)"

  node -e '
const fs = require("node:fs")
const path = require("node:path")

const configPath = process.argv[1]
const enabled = process.argv[2] === "1"
const command = process.argv[3] === "" ? null : process.argv[3]
const provider = process.argv[4] === "http" ? "http" : process.argv[4] === "command" ? "command" : "worker"
const LEGACY_PARAKEET_MODELS = new Set([
  "parakeet-v3",
  "nvidia/parakeet-tdt-0.6b-v3",
])

let parsed = {
  version: 1,
  ottoHome: path.join(process.env.HOME, ".otto"),
  opencode: { hostname: "0.0.0.0", port: 4096 },
}

if (fs.existsSync(configPath)) {
  parsed = JSON.parse(fs.readFileSync(configPath, "utf8"))
}

const telegram = parsed.telegram || {}
const voice = telegram.voice || {}
const transcription = telegram.transcription || {}

parsed.telegram = {
  ...telegram,
  voice: {
    enabled,
    maxDurationSec: Number.isInteger(voice.maxDurationSec) ? voice.maxDurationSec : 180,
    maxBytes: Number.isInteger(voice.maxBytes) ? voice.maxBytes : 10 * 1024 * 1024,
    downloadTimeoutMs: Number.isInteger(voice.downloadTimeoutMs) ? voice.downloadTimeoutMs : 20000,
  },
  transcription: {
    provider,
    timeoutMs: Number.isInteger(transcription.timeoutMs) && transcription.timeoutMs >= 300000 ? transcription.timeoutMs : 300000,
    workerStartupTimeoutMs: Number.isInteger(transcription.workerStartupTimeoutMs) && transcription.workerStartupTimeoutMs >= 600000 ? transcription.workerStartupTimeoutMs : 600000,
    language: provider === "worker"
      ? "auto"
      : (typeof transcription.language === "string" && transcription.language.length > 0 ? transcription.language : "auto"),
    model: (() => {
      const configuredModel = typeof transcription.model === "string" ? transcription.model.trim() : ""
      if (provider === "worker") {
        if (configuredModel.length === 0 || LEGACY_PARAKEET_MODELS.has(configuredModel) || configuredModel.toLowerCase().includes("parakeet")) {
          return "small"
        }
      }
      return configuredModel.length > 0 ? configuredModel : "small"
    })(),
    command,
    commandArgs: Array.isArray(transcription.commandArgs) && transcription.commandArgs.every((value) => typeof value === "string")
      ? transcription.commandArgs
      : ["{input}"],
    workerScriptPath: typeof transcription.workerScriptPath === "string" && transcription.workerScriptPath.length > 0
      ? transcription.workerScriptPath
      : null,
    workerPythonPath: typeof transcription.workerPythonPath === "string" && transcription.workerPythonPath.length > 0
      ? transcription.workerPythonPath
      : null,
    baseUrl: typeof transcription.baseUrl === "string" && transcription.baseUrl.length > 0
      ? transcription.baseUrl
      : "http://127.0.0.1:9000",
    httpPath: typeof transcription.httpPath === "string" && transcription.httpPath.length > 0
      ? transcription.httpPath
      : "/v1/audio/transcriptions",
  },
}

fs.mkdirSync(path.dirname(configPath), { recursive: true })
fs.writeFileSync(configPath, `${JSON.stringify(parsed, null, 2)}\n`, "utf8")
' "${config_path}" "${enabled}" "${command_value}" "${provider_value}"
}

attempt_auto_provision_faster_whisper() {

  local install_helper="${CURRENT_LINK}/scripts/install-parakeet-v3.sh"

  if [[ -x "${install_helper}" ]]; then
    "${install_helper}"
    return $?
  fi

  return 1
}

is_faster_whisper_runtime_ready() {
  local default_python_path="${OTTO_ROOT}/models/faster-whisper/.venv/bin/python"

  if [[ ! -x "${default_python_path}" ]]; then
    return 1
  fi

  if ! "${default_python_path}" - <<'PY' >/dev/null 2>&1
from faster_whisper import WhisperModel  # noqa: F401
print("ok")
PY
  then
    return 1
  fi

  return 0
}

cmd_configure_voice_transcription() {
  if ! cd "${HOME}"; then
    warn "Could not change working directory to ${HOME}; continuing setup anyway"
  fi

  if is_faster_whisper_runtime_ready; then
    update_telegram_voice_settings "1" "" "worker"
    info "Faster-Whisper runtime already installed; skipping setup prompt"
    return 0
  fi

  if [[ ! -t 0 || ! -t 1 ]]; then
    info "Voice transcription setup skipped in non-interactive mode"
    return 0
  fi

  local enable_voice=""
  while true; do
    read -r -p "Enable local voice transcription (Faster-Whisper) now? [y/N]: " enable_voice
    case "${enable_voice:-N}" in
      Y|y)
        break
        ;;
      N|n|"")
        update_telegram_voice_settings "0" "" "worker"
        info "Voice transcription disabled in settings"
        return 0
        ;;
      *)
        warn "Please answer y or N"
        ;;
    esac
  done

  info "Attempting automatic local Faster-Whisper provisioning..."
  if attempt_auto_provision_faster_whisper; then
    update_telegram_voice_settings "1" "" "worker"
    success "Voice transcription enabled with persistent Faster-Whisper worker backend"
    return 0
  fi

  warn "Automatic Faster-Whisper setup failed"
  update_telegram_voice_settings "1" "" "worker"
  warn "Voice intake stays enabled, but transcription worker could not be provisioned"
  warn "Telegram voice messages will receive a 'cannot transcribe yet' notice until provisioning succeeds"
}

validate_task_profile_file() {
  local profile_path="$1"

  node -e '
const fs = require("node:fs")
const path = process.argv[1]
const expectedId = process.argv[2] || ""
let parsed
try {
  parsed = JSON.parse(fs.readFileSync(path, "utf8"))
} catch {
  console.error(`Invalid JSON in profile: ${path}`)
  process.exit(1)
}

if (!parsed || parsed.version !== 1) {
  console.error(`Invalid profile version in ${path}`)
  process.exit(1)
}

if (typeof parsed.id !== "string" || parsed.id.trim().length === 0) {
  console.error(`Profile id is required in ${path}`)
  process.exit(1)
}

if (expectedId && parsed.id !== expectedId) {
  console.error(`Profile id mismatch in ${path}: expected ${expectedId}, got ${parsed.id}`)
  process.exit(1)
}

if (parsed.laneOverrides != null && (typeof parsed.laneOverrides !== "object" || Array.isArray(parsed.laneOverrides))) {
  console.error(`laneOverrides must be an object in ${path}`)
  process.exit(1)
}

for (const lane of ["interactive", "scheduled"]) {
  const laneValue = parsed.laneOverrides?.[lane]
  if (laneValue == null) continue
  if (typeof laneValue !== "object" || Array.isArray(laneValue)) {
    console.error(`${lane} override must be an object in ${path}`)
    process.exit(1)
  }
  if (laneValue.opencode == null || typeof laneValue.opencode !== "object" || Array.isArray(laneValue.opencode)) {
    console.error(`${lane}.opencode must be an object in ${path}`)
    process.exit(1)
  }
}
' "${profile_path}" "$2"
}

require_task_runtime_paths() {
  if [[ -z "${TASK_PROFILE_DIR}" || -z "${STATE_DB_PATH}" ]]; then
    error "Task runtime paths are not initialized"
    exit 1
  fi
}

require_state_db() {
  if [[ ! -f "${STATE_DB_PATH}" ]]; then
    error "State database not found: ${STATE_DB_PATH}. Run setup first."
    exit 1
  fi
}

node_print_query_table() {
  local query="$1"
  local params_json="${2:-[]}"

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const query = process.argv[2]
const paramsJson = process.argv[3] ?? "[]"
const params = JSON.parse(paramsJson)

const db = new DatabaseSync(dbPath)
try {
  const rows = db.prepare(query).all(...params)
  if (!rows.length) {
    console.log("(no rows)")
    process.exit(0)
  }

  const columns = Object.keys(rows[0])
  console.log(columns.join("\t"))
  for (const row of rows) {
    const line = columns
      .map((column) => {
        const value = row[column]
        return value == null ? "" : String(value).replaceAll("\n", "\\n")
      })
      .join("\t")
    console.log(line)
  }
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${query}" "${params_json}"
}

node_print_tasks_table() {
  local maybe_task_id="${1:-}"

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const taskId = process.argv[2] ?? ""
const db = new DatabaseSync(dbPath)

const printRows = (rows) => {
  if (!rows.length) {
    console.log("(no rows)")
    return
  }

  const columns = [
    "id",
    "type",
    "schedule_type",
    "profile_id",
    "status",
    "next_run_at",
    "terminal_state",
  ]
  console.log(columns.join("\t"))
  for (const row of rows) {
    console.log(columns.map((col) => (row[col] == null ? "" : String(row[col]))).join("\t"))
  }
}

try {
  const columns = new Set(db.prepare("PRAGMA table_info(jobs)").all().map((row) => row.name))
  const has = (column) => columns.has(column)
  const selectExpr = [
    "id",
    "type",
    has("schedule_type") ? "schedule_type" : "NULL AS schedule_type",
    has("profile_id") ? "profile_id" : "NULL AS profile_id",
    "status",
    has("next_run_at") ? "next_run_at" : "NULL AS next_run_at",
    has("terminal_state") ? "terminal_state" : "NULL AS terminal_state",
  ].join(", ")

  if (taskId) {
    const rows = db.prepare(`SELECT ${selectExpr} FROM jobs WHERE id = ?`).all(taskId)
    printRows(rows)
    process.exit(0)
  }

  const rows = db.prepare(`SELECT ${selectExpr} FROM jobs ORDER BY id ASC`).all()
  printRows(rows)
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${maybe_task_id}"
}

cmd_task_profiles_list() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local found=0
  while IFS= read -r profile_path; do
    found=1
    node -e 'const fs=require("node:fs"); const p=process.argv[1]; try {const obj=JSON.parse(fs.readFileSync(p,"utf8")); process.stdout.write(`${obj.id || "<invalid-id>"}\t${p}\n`)} catch {process.stdout.write(`<invalid>\t${p}\n`)}' "${profile_path}"
  done < <(find "${TASK_PROFILE_DIR}" -maxdepth 1 -type f -name "*.jsonc" -print 2>/dev/null | sort)

  if [[ ${found} -eq 0 ]]; then
    info "No task profiles installed in ${TASK_PROFILE_DIR}"
  fi
}

cmd_task_profiles_validate() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local profile_id="${1:-}"
  if [[ -z "${profile_id}" ]]; then
    local any=0
    while IFS= read -r profile_path; do
      any=1
      local filename expected_id
      filename="$(basename "${profile_path}")"
      expected_id="${filename%.jsonc}"
      validate_task_profile_file "${profile_path}" "${expected_id}"
      success "Valid: ${expected_id}"
    done < <(find "${TASK_PROFILE_DIR}" -maxdepth 1 -type f -name "*.jsonc" -print 2>/dev/null | sort)

    if [[ ${any} -eq 0 ]]; then
      warn "No profiles found to validate in ${TASK_PROFILE_DIR}"
    fi
    return
  fi

  local profile_path="${TASK_PROFILE_DIR}/${profile_id}.jsonc"
  if [[ ! -f "${profile_path}" ]]; then
    error "Profile not found: ${profile_id}"
    exit 1
  fi

  validate_task_profile_file "${profile_path}" "${profile_id}"
  success "Valid: ${profile_id}"
}

cmd_task_profiles_install() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local source_path="${1:-}"
  if [[ -z "${source_path}" ]]; then
    error "Usage: ottoctl task profiles install <profile-file.jsonc>"
    exit 1
  fi

  if [[ ! -f "${source_path}" ]]; then
    error "Profile file not found: ${source_path}"
    exit 1
  fi

  local filename expected_id target_path
  filename="$(basename "${source_path}")"
  expected_id="${filename%.jsonc}"
  target_path="${TASK_PROFILE_DIR}/${filename}"

  validate_task_profile_file "${source_path}" "${expected_id}"
  cp "${source_path}" "${target_path}"
  chmod 600 "${target_path}" || true

  success "Installed task profile: ${expected_id}"
}

cmd_task_bind_profile() {
  require_task_runtime_paths
  require_state_db

  local task_id="${1:-}"
  local profile_id="${2:-}"

  if [[ -z "${task_id}" || -z "${profile_id}" ]]; then
    error "Usage: ottoctl task bind-profile <task-id> <profile-id>"
    exit 1
  fi

  local profile_path="${TASK_PROFILE_DIR}/${profile_id}.jsonc"
  if [[ ! -f "${profile_path}" ]]; then
    error "Profile not found: ${profile_id}"
    exit 1
  fi

  validate_task_profile_file "${profile_path}" "${profile_id}"

  if node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const taskId = process.argv[2]
const profileId = process.argv[3]
const now = Date.now()

const db = new DatabaseSync(dbPath)
try {
  const columns = new Set(db.prepare("PRAGMA table_info(jobs)").all().map((row) => row.name))
  if (!columns.has("profile_id")) {
    process.exit(3)
  }

  const result = db
    .prepare("UPDATE jobs SET profile_id = ?, updated_at = ? WHERE id = ?")
    .run(profileId, now, taskId)

  if ((result.changes ?? 0) < 1) {
    process.exit(2)
  }
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${task_id}" "${profile_id}"
  then
    :
  else
    local update_status=$?
    if [[ ${update_status} -eq 2 ]]; then
      error "Task not found: ${task_id}"
      exit 1
    fi
    if [[ ${update_status} -eq 3 ]]; then
      error "Current state database does not support profile bindings yet. Run ottoctl update/setup first."
      exit 1
    fi
    exit ${update_status}
  fi

  success "Bound task ${task_id} to profile ${profile_id}"
}

cmd_task_show() {
  require_task_runtime_paths
  require_state_db

  local task_id="${1:-}"
  if [[ -z "${task_id}" ]]; then
    error "Usage: ottoctl task show <task-id>"
    exit 1
  fi

  node_print_tasks_table "${task_id}"
}

cmd_task_list() {
  require_task_runtime_paths
  require_state_db

  node_print_tasks_table
}

cmd_task_audit() {
  require_task_runtime_paths
  require_state_db

  local limit="${1:-50}"
  if ! [[ "${limit}" =~ ^[0-9]+$ ]] || [[ "${limit}" -lt 1 ]] || [[ "${limit}" -gt 200 ]]; then
    error "Usage: ottoctl task audit [limit:1-200]"
    exit 1
  fi

  info "Recent task audit records (limit=${limit})"
  node_print_query_table \
    "SELECT id, task_id, action, lane, actor, created_at FROM task_audit_log ORDER BY created_at DESC LIMIT ?" \
    "[${limit}]"
  echo
  info "Recent command audit records (limit=${limit})"
  node_print_query_table \
    "SELECT id, command, lane, status, error_message, created_at FROM command_audit_log ORDER BY created_at DESC LIMIT ?" \
    "[${limit}]"
}

cmd_task_run_now() {
  require_task_runtime_paths
  require_state_db

  local task_id="${1:-}"
  if [[ -z "${task_id}" ]]; then
    error "Usage: ottoctl task run-now <task-id>"
    exit 1
  fi

  local run_at
  run_at="$(node -e 'process.stdout.write(String(Date.now()))')"

  if node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const taskId = process.argv[2]
const runAt = Number(process.argv[3])

const db = new DatabaseSync(dbPath)
try {
  const columns = new Set(db.prepare("PRAGMA table_info(jobs)").all().map((row) => row.name))
  if (!columns.has("next_run_at")) {
    process.exit(3)
  }

  const task = db
    .prepare("SELECT id, status FROM jobs WHERE id = ?")
    .get(taskId)

  if (!task) {
    process.exit(2)
  }

  if (task.status === "paused") {
    process.exit(4)
  }

  db.prepare(
    `UPDATE jobs
     SET status = ?,
         next_run_at = ?,
         lock_token = ?,
         lock_expires_at = ?,
         updated_at = ?
     WHERE id = ?`
  ).run("idle", runAt, null, null, runAt, taskId)
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${task_id}" "${run_at}"
  then
    :
  else
    local run_status=$?
    if [[ ${run_status} -eq 2 ]]; then
      error "Task not found: ${task_id}"
      exit 1
    fi
    if [[ ${run_status} -eq 3 ]]; then
      error "Current state database does not support scheduler next_run_at yet. Run ottoctl update/setup first."
      exit 1
    fi
    if [[ ${run_status} -eq 4 ]]; then
      error "Task is paused: ${task_id}. Resume it first before run-now."
      exit 1
    fi
    exit ${run_status}
  fi

  success "Scheduled immediate run for task ${task_id}"
  info "Scheduler executes on next tick (usually within 60s)."
}

cmd_task() {
  local subcommand="${1:-}"
  shift || true

  case "${subcommand}" in
    profiles)
      local profile_action="${1:-list}"
      shift || true
      case "${profile_action}" in
        list)
          cmd_task_profiles_list "$@"
          ;;
        validate)
          cmd_task_profiles_validate "$@"
          ;;
        install)
          cmd_task_profiles_install "$@"
          ;;
        *)
          error "Unknown task profiles command: ${profile_action}"
          exit 1
          ;;
      esac
      ;;
    bind-profile)
      cmd_task_bind_profile "$@"
      ;;
    list)
      cmd_task_list "$@"
      ;;
    show)
      cmd_task_show "$@"
      ;;
    audit)
      cmd_task_audit "$@"
      ;;
    run-now)
      cmd_task_run_now "$@"
      ;;
    set-model)
      run_model_cli task set-model "$@"
      ;;
    *)
      error "Unknown task command: ${subcommand}"
      exit 1
      ;;
  esac
}

run_extension_cli() {
  NODE_ENV=production OTTO_HOME="${OTTO_HOME}" node "${CURRENT_LINK}/dist/extension-cli.mjs" "$@"
}

run_model_cli() {
  NODE_ENV=production OTTO_HOME="${OTTO_HOME}" node "${CURRENT_LINK}/dist/model-cli.mjs" "$@"
}

run_prompt_cli() {
  NODE_ENV=production OTTO_HOME="${OTTO_HOME}" node "${CURRENT_LINK}/dist/prompt-cli.mjs" "$@"
}

cmd_model() {
  run_model_cli model "$@"
}

cmd_prompt() {
  local subcommand="${1:-}"
  shift || true

  case "${subcommand}" in
    ""|prompt)
      run_prompt_cli prompt "$@"
      ;;
    help|--help|-h)
      run_prompt_cli --help
      ;;
    *)
      error "Unknown prompt command: ${subcommand}"
      exit 1
      ;;
  esac
}

cmd_extension() {
  local subcommand="${1:-}"
  shift || true

  case "${subcommand}" in
    list)
      run_extension_cli list "$@"
      ;;
    install)
      run_extension_cli install "$@"
      ;;
    update)
      run_extension_cli update "$@"
      ;;
    disable)
      run_extension_cli disable "$@"
      ;;
    remove)
      run_extension_cli remove "$@"
      ;;
    help|--help|-h|"")
      run_extension_cli --help
      ;;
    *)
      error "Unknown extension command: ${subcommand}"
      exit 1
      ;;
  esac
}

cmd_env_path() {
  echo "${RUNTIME_ENV_FILE}"
}

cmd_env_list() {
  ensure_runtime_env_file
  info "Runtime environment file: ${RUNTIME_ENV_FILE}"
  if [[ ! -s "${RUNTIME_ENV_FILE}" ]]; then
    echo "(empty)"
    return
  fi

  cat "${RUNTIME_ENV_FILE}"
}

cmd_env_set() {
  local key="${1:-}"
  local value="${2:-}"

  if [[ -z "${key}" || -z "${value}" ]]; then
    error "Usage: ottoctl env set <KEY> <VALUE>"
    exit 1
  fi

  if ! is_valid_env_key "${key}"; then
    error "Invalid environment variable key: ${key}"
    exit 1
  fi

  set_runtime_env_value "${key}" "${value}"
  success "Saved ${key} to ${RUNTIME_ENV_FILE}"
  info "Run: ottoctl restart (or ottoctl stop && ottoctl start) to apply"
}

cmd_env_unset() {
  local key="${1:-}"

  if [[ -z "${key}" ]]; then
    error "Usage: ottoctl env unset <KEY>"
    exit 1
  fi

  if ! is_valid_env_key "${key}"; then
    error "Invalid environment variable key: ${key}"
    exit 1
  fi

  unset_runtime_env_value "${key}"
  success "Removed ${key} from ${RUNTIME_ENV_FILE}"
  info "Run: ottoctl restart (or ottoctl stop && ottoctl start) to apply"
}

cmd_env() {
  local subcommand="${1:-list}"
  shift || true

  case "${subcommand}" in
    list)
      cmd_env_list "$@"
      ;;
    path)
      cmd_env_path "$@"
      ;;
    set)
      cmd_env_set "$@"
      ;;
    unset)
      cmd_env_unset "$@"
      ;;
    *)
      error "Unknown env command: ${subcommand}"
      exit 1
      ;;
  esac
}

cmd_heartbeat_mode() {
  require_state_db

  local mode="${1:-}"
  if [[ -z "${mode}" ]]; then
    error "Usage: ottoctl heartbeat mode <observe|mute>"
    exit 1
  fi

  if [[ "${mode}" != "observe" && "${mode}" != "mute" ]]; then
    error "Unknown heartbeat mode: ${mode}. Valid modes: observe, mute"
    exit 1
  fi

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const mode = process.argv[2]
const now = Date.now()
const muteFarFuture = now + 10 * 365 * 24 * 60 * 60 * 1000

const db = new DatabaseSync(dbPath)
try {
  db.exec("BEGIN")

  const existing = db.prepare("SELECT 1 FROM user_profile WHERE id = 1").get()
  if (!existing) {
    db.prepare(
      `INSERT INTO user_profile
        (id, timezone, quiet_hours_start, quiet_hours_end, quiet_mode, mute_until, heartbeat_morning, heartbeat_midday, heartbeat_evening, heartbeat_cadence_minutes, heartbeat_only_if_signal, onboarding_completed_at, last_digest_at, updated_at)
       VALUES (1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    ).run("Europe/Vienna", "20:00", "08:00", "critical_only", null, "08:30", "12:30", "19:00", 180, 1, now, null, now)
  }

  if (mode === "observe") {
    db.prepare(
      `UPDATE user_profile
       SET heartbeat_only_if_signal = 0,
           quiet_mode = 'off',
           mute_until = NULL,
           updated_at = ?
       WHERE id = 1`
    ).run(now)
  } else {
    db.prepare(
      `UPDATE user_profile
       SET heartbeat_only_if_signal = 1,
           quiet_mode = 'critical_only',
           mute_until = ?,
           updated_at = ?
       WHERE id = 1`
    ).run(muteFarFuture, now)
  }

  db.exec("COMMIT")
} catch (error) {
  db.exec("ROLLBACK")
  throw error
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${mode}"

  if [[ "${mode}" == "observe" ]]; then
    success "Heartbeat mode set to observe (always send compact updates)."
  else
    success "Heartbeat mode set to mute (normal heartbeats suppressed)."
  fi
}

cmd_heartbeat_status() {
  require_state_db

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const now = Date.now()
const db = new DatabaseSync(dbPath)
try {
  const row = db.prepare(
    `SELECT
      quiet_mode as quietMode,
      mute_until as muteUntil,
      heartbeat_only_if_signal as heartbeatOnlyIfSignal,
      heartbeat_morning as heartbeatMorning,
      heartbeat_midday as heartbeatMidday,
      heartbeat_evening as heartbeatEvening,
      heartbeat_cadence_minutes as heartbeatCadenceMinutes
     FROM user_profile
     WHERE id = 1`
  ).get()

  if (!row) {
    console.log("Heartbeat profile: not initialized")
    process.exit(0)
  }

  const muted = typeof row.muteUntil === "number" && row.muteUntil > now
  const mode = muted ? "mute" : "observe"
  const onlyIfSignal = row.heartbeatOnlyIfSignal === 0 ? "off" : "on"

  console.log(`mode\t${mode}`)
  console.log(`heartbeat_only_if_signal\t${onlyIfSignal}`)
  console.log(`quiet_mode\t${row.quietMode ?? "critical_only"}`)
  console.log(`mute_until\t${row.muteUntil ?? ""}`)
  console.log(`windows\t${row.heartbeatMorning ?? "-"} / ${row.heartbeatMidday ?? "-"} / ${row.heartbeatEvening ?? "-"}`)
  console.log(`cadence_minutes\t${row.heartbeatCadenceMinutes ?? ""}`)
} finally {
  db.close()
}
' "${STATE_DB_PATH}"
}

cmd_heartbeat() {
  local subcommand="${1:-status}"
  shift || true

  case "${subcommand}" in
    mode)
      cmd_heartbeat_mode "$@"
      ;;
    status)
      cmd_heartbeat_status "$@"
      ;;
    *)
      error "Unknown heartbeat command: ${subcommand}"
      exit 1
      ;;
  esac
}

resolve_repo() {
  local explicit_repo="${1:-}"
  if [[ -n "${explicit_repo}" ]]; then
    echo "${explicit_repo}"
    return
  fi

  if [[ -n "${OTTO_GITHUB_REPO:-}" ]]; then
    echo "${OTTO_GITHUB_REPO}"
    return
  fi

  echo "${DEFAULT_REPO}"
}

fetch_release_info() {
  local repo="$1"
  local channel="$2"

  node "${CURRENT_LINK}/scripts/resolve-release.mjs" "${repo}" "${channel}"
}

install_release() {
  local tag="$1"
  local artifact_url="$2"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap '[[ -n "${tmp_dir:-}" ]] && rm -rf "${tmp_dir}"' RETURN

  mkdir -p "${RELEASES_DIR}" "${BIN_DIR}"

  info "Downloading ${tag}..."
  curl -fsSL "${artifact_url}" -o "${tmp_dir}/otto.tgz"

  local release_dir="${RELEASES_DIR}/${tag}"
  rm -rf "${release_dir}"
  mkdir -p "${release_dir}"
  tar -xzf "${tmp_dir}/otto.tgz" -C "${release_dir}"

  ln -sfn "${release_dir}" "${CURRENT_LINK}"

  if [[ -f "${CURRENT_LINK}/bin/ottoctl" ]]; then
    local target_cli="${BIN_DIR}/ottoctl"
    local staged_cli="${BIN_DIR}/.ottoctl.$$"

    cp "${CURRENT_LINK}/bin/ottoctl" "${staged_cli}"
    chmod +x "${staged_cli}"
    mv -f "${staged_cli}" "${target_cli}"
    chmod +x "${BIN_DIR}/ottoctl"
  fi

  success "Installed ${tag}"
}

run_setup() {
  require_cmd node
  NODE_ENV=production node "${CURRENT_LINK}/dist/index.mjs" setup
}

install_service_linux() {
  local node_path
  node_path="$(command -v node)"
  local service_path
  service_path="$(build_service_path)"
  local user_dir="${HOME}/.config/systemd/user"
  local service_file="${user_dir}/${SERVICE_NAME}.service"
  local control_plane_service_file="${user_dir}/${CONTROL_PLANE_SERVICE_NAME}.service"

  mkdir -p "${user_dir}"

  cat > "${service_file}" <<EOF
[Unit]
Description=Otto Personal Assistant
After=network.target

[Service]
Type=simple
ExecStart=${node_path} ${CURRENT_LINK}/dist/index.mjs serve
WorkingDirectory=${HOME}
Restart=on-failure
RestartSec=5
EnvironmentFile=-${RUNTIME_ENV_FILE}
Environment=HOME=${HOME}
Environment=PATH=${service_path}
Environment=NODE_ENV=production
StandardOutput=journal
StandardError=journal
SyslogIdentifier=otto

[Install]
WantedBy=default.target
EOF

  if has_control_plane_release; then
    local control_plane_host
    control_plane_host="$(resolve_control_plane_host)"
    local control_plane_port
    control_plane_port="$(resolve_control_plane_port)"
    local control_plane_server
    control_plane_server="$(control_plane_server_path)"
    local control_plane_serve_cli
    control_plane_serve_cli="$(control_plane_serve_cli_path)"

    cat > "${control_plane_service_file}" <<EOF
[Unit]
Description=Otto Control Plane
After=network.target

[Service]
Type=simple
ExecStart=${node_path} ${control_plane_serve_cli} ${control_plane_server}
WorkingDirectory=${CURRENT_LINK}/control-plane
Restart=on-failure
RestartSec=5
EnvironmentFile=-${RUNTIME_ENV_FILE}
Environment=HOME=${HOME}
Environment=PATH=${service_path}
Environment=NODE_ENV=production
Environment=HOST=${control_plane_host}
Environment=PORT=${control_plane_port}
StandardOutput=journal
StandardError=journal
SyslogIdentifier=otto-control-plane

[Install]
WantedBy=default.target
EOF
  else
    systemctl --user disable --now "${CONTROL_PLANE_SERVICE_NAME}" >/dev/null 2>&1 || true
    rm -f "${control_plane_service_file}"
    warn "Control-plane artifact missing in current release; skipping control-plane service install"
  fi

  systemctl --user daemon-reload
  systemctl --user enable "${SERVICE_NAME}" >/dev/null

  if has_control_plane_release; then
    systemctl --user enable "${CONTROL_PLANE_SERVICE_NAME}" >/dev/null
  fi

  if command -v loginctl >/dev/null 2>&1; then
    loginctl enable-linger "$(whoami)" >/dev/null 2>&1 || true
  fi
}

install_service_macos() {
  local node_path
  node_path="$(command -v node)"
  local service_path
  service_path="$(build_service_path)"
  local runtime_env_keys=""
  runtime_env_keys="$(runtime_env_plist_entries)"

  mkdir -p "${HOME}/Library/LaunchAgents"

  cat > "${PLIST_FILE}" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>${PLIST_LABEL}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${node_path}</string>
    <string>${CURRENT_LINK}/dist/index.mjs</string>
    <string>serve</string>
  </array>
  <key>WorkingDirectory</key>
  <string>${HOME}</string>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>EnvironmentVariables</key>
  <dict>
    <key>HOME</key>
    <string>${HOME}</string>
    <key>PATH</key>
    <string>${service_path}</string>
    <key>NODE_ENV</key>
    <string>production</string>
${runtime_env_keys}
  </dict>
  <key>StandardOutPath</key>
  <string>${HOME}/.local/share/otto/logs/service.log</string>
  <key>StandardErrorPath</key>
  <string>${HOME}/.local/share/otto/logs/service.err.log</string>
</dict>
</plist>
EOF

  if has_control_plane_release; then
    local control_plane_host
    control_plane_host="$(resolve_control_plane_host)"
    local control_plane_port
    control_plane_port="$(resolve_control_plane_port)"
    local control_plane_server
    control_plane_server="$(control_plane_server_path)"
    local control_plane_serve_cli
    control_plane_serve_cli="$(control_plane_serve_cli_path)"

    cat > "${CONTROL_PLANE_PLIST_FILE}" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>${CONTROL_PLANE_PLIST_LABEL}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${node_path}</string>
    <string>${control_plane_serve_cli}</string>
    <string>${control_plane_server}</string>
  </array>
  <key>WorkingDirectory</key>
  <string>${CURRENT_LINK}/control-plane</string>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>EnvironmentVariables</key>
  <dict>
    <key>HOME</key>
    <string>${HOME}</string>
    <key>PATH</key>
    <string>${service_path}</string>
    <key>NODE_ENV</key>
    <string>production</string>
${runtime_env_keys}
    <key>HOST</key>
    <string>${control_plane_host}</string>
    <key>PORT</key>
    <string>${control_plane_port}</string>
  </dict>
  <key>StandardOutPath</key>
  <string>${HOME}/.local/share/otto/logs/control-plane.log</string>
  <key>StandardErrorPath</key>
  <string>${HOME}/.local/share/otto/logs/control-plane.err.log</string>
</dict>
</plist>
EOF
  else
    launchctl bootout "gui/$(id -u)" "${CONTROL_PLANE_PLIST_FILE}" >/dev/null 2>&1 || true
    rm -f "${CONTROL_PLANE_PLIST_FILE}"
    warn "Control-plane artifact missing in current release; skipping control-plane service install"
  fi
}

install_service() {
  local platform
  platform="$(detect_platform)"

  mkdir -p "${OTTO_ROOT}/logs"

  if [[ "${platform}" == "linux" ]]; then
    install_service_linux
  else
    install_service_macos
  fi
}

start_service() {
  local platform
  platform="$(detect_platform)"

  if [[ "${platform}" == "linux" ]]; then
    systemctl --user start "${SERVICE_NAME}"
    if has_control_plane_release; then
      systemctl --user start "${CONTROL_PLANE_SERVICE_NAME}"
    else
      systemctl --user stop "${CONTROL_PLANE_SERVICE_NAME}" >/dev/null 2>&1 || true
    fi
  else
    launchctl bootout "gui/$(id -u)" "${PLIST_FILE}" >/dev/null 2>&1 || true
    launchctl bootstrap "gui/$(id -u)" "${PLIST_FILE}"
    launchctl kickstart -k "gui/$(id -u)/${PLIST_LABEL}"

    if has_control_plane_release; then
      launchctl bootout "gui/$(id -u)" "${CONTROL_PLANE_PLIST_FILE}" >/dev/null 2>&1 || true
      launchctl bootstrap "gui/$(id -u)" "${CONTROL_PLANE_PLIST_FILE}"
      launchctl kickstart -k "gui/$(id -u)/${CONTROL_PLANE_PLIST_LABEL}"
    else
      launchctl bootout "gui/$(id -u)" "${CONTROL_PLANE_PLIST_FILE}" >/dev/null 2>&1 || true
    fi
  fi
}

stop_service() {
  local platform
  platform="$(detect_platform)"

  if [[ "${platform}" == "linux" ]]; then
    systemctl --user stop "${CONTROL_PLANE_SERVICE_NAME}" >/dev/null 2>&1 || true
    systemctl --user stop "${SERVICE_NAME}"
  else
    launchctl bootout "gui/$(id -u)" "${CONTROL_PLANE_PLIST_FILE}" >/dev/null 2>&1 || true
    launchctl bootout "gui/$(id -u)" "${PLIST_FILE}" >/dev/null 2>&1 || true
  fi
}

restart_service() {
  stop_service || true
  start_service
}

ensure_safe_working_directory() {
  if pwd >/dev/null 2>&1; then
    return
  fi

  if ! cd "${HOME}"; then
    warn "Could not change working directory to ${HOME}; continuing anyway"
  fi
}

write_install_meta() {
  local repo="$1"
  mkdir -p "${OTTO_ROOT}"
  cat > "${INSTALL_META}" <<EOF
OTTO_GITHUB_REPO=${repo}
OTTO_ROOT=${OTTO_ROOT}
OTTO_BIN_DIR=${BIN_DIR}
EOF
}

cmd_update() {
  local channel="stable"
  local repo_override=""
  local pr_number=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --nightly)
        channel="nightly"
        shift
        ;;
      --repo)
        repo_override="${2:-}"
        shift 2
        ;;
      --pr)
        pr_number="${2:-}"
        if [[ ! "${pr_number}" =~ ^[0-9]+$ ]]; then
          error "--pr expects a pull request number"
          exit 1
        fi
        channel="pr-${pr_number}"
        shift 2
        ;;
      *)
        error "Unknown option for update: $1"
        exit 1
        ;;
    esac
  done

  local repo
  repo="$(resolve_repo "${repo_override}")"

  local release_info
  release_info="$(fetch_release_info "${repo}" "${channel}")"
  local tag artifact_url artifact_name
  tag="$(printf '%s\n' "${release_info}" | sed -n '1p')"
  artifact_url="$(printf '%s\n' "${release_info}" | sed -n '2p')"
  artifact_name="$(printf '%s\n' "${release_info}" | sed -n '3p')"

  info "Using artifact ${artifact_name} (${tag})"

  if ! cd "${HOME}"; then
    warn "Could not change working directory to ${HOME}; continuing update anyway"
  fi

  install_release "${tag}" "${artifact_url}"
  write_install_meta "${repo}"
  run_setup
  ensure_telegram_credentials || true
  cmd_configure_voice_transcription || true
  install_service
  restart_service

  success "Otto updated to ${tag}"
}

cmd_start() {
  install_service
  start_service
  success "Otto services started"
}

cmd_restart() {
  install_service
  restart_service
  success "Otto services restarted"
}

cmd_stop() {
  stop_service
  success "Otto services stopped"
}

cmd_configure_telegram() {
  if ensure_telegram_credentials; then
    success "Telegram credential setup complete"
  else
    warn "Telegram credential setup skipped"
  fi
}

cmd_help() {
  cat <<'EOF'
ottoctl - Otto server control

Usage:
  ottoctl start
  ottoctl restart
  ottoctl stop
  ottoctl configure-telegram
  ottoctl configure-voice-transcription
  ottoctl env list
  ottoctl env path
  ottoctl env set <KEY> <VALUE>
  ottoctl env unset <KEY>
  ottoctl task profiles list
  ottoctl task profiles validate [profile-id]
  ottoctl task profiles install <profile-file.jsonc>
  ottoctl task list
  ottoctl task bind-profile <task-id> <profile-id>
  ottoctl task set-model <task-id> <provider/model|inherit>
  ottoctl task show <task-id>
  ottoctl task audit [limit]
  ottoctl task run-now <task-id>
  ottoctl model list
  ottoctl model refresh
  ottoctl model defaults show
  ottoctl model defaults set <flow> <provider/model|inherit>
  ottoctl heartbeat status
  ottoctl heartbeat mode <observe|mute>
  ottoctl prompt
  ottoctl extension list
  ottoctl extension install <id>[@version]
  ottoctl extension update <id>
  ottoctl extension update --all
  ottoctl extension disable <id>
  ottoctl extension remove <id>[@version]
  ottoctl update [--nightly] [--pr number] [--repo owner/repo]
EOF
}

main() {
  require_cmd curl
  require_cmd tar
  require_cmd node

  ensure_safe_working_directory

  load_install_meta
  load_telegram_env
  load_runtime_env
  OTTO_HOME="$(resolve_otto_home)"
  TASK_CONFIG_DIR="${OTTO_HOME}/task-config"
  TASK_PROFILE_DIR="${TASK_CONFIG_DIR}/profiles"
  STATE_DB_PATH="${OTTO_HOME}/data/otto-state.db"

  case "${1:-help}" in
    start)
      shift
      cmd_start "$@"
      ;;
    stop)
      shift
      cmd_stop "$@"
      ;;
    restart)
      shift
      cmd_restart "$@"
      ;;
    configure-telegram)
      shift
      cmd_configure_telegram "$@"
      ;;
    configure-voice-transcription)
      shift
      cmd_configure_voice_transcription "$@"
      ;;
    task)
      shift
      cmd_task "$@"
      ;;
    model)
      shift
      cmd_model "$@"
      ;;
    heartbeat)
      shift
      cmd_heartbeat "$@"
      ;;
    prompt)
      shift
      cmd_prompt "$@"
      ;;
    extension)
      shift
      cmd_extension "$@"
      ;;
    env)
      shift
      cmd_env "$@"
      ;;
    update)
      shift
      cmd_update "$@"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      error "Unknown command: $1"
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
