#!/usr/bin/env bash
set -euo pipefail

OTTO_ROOT="${OTTO_ROOT:-$HOME/.local/share/otto}"
RELEASES_DIR="${OTTO_ROOT}/releases"
CURRENT_LINK="${OTTO_ROOT}/current"
INSTALL_META="${OTTO_ROOT}/install.env"
SECRETS_DIR="${OTTO_ROOT}/secrets"
TELEGRAM_ENV_FILE="${SECRETS_DIR}/telegram.env"
RUNTIME_ENV_FILE="${SECRETS_DIR}/runtime.env"
BIN_DIR="${OTTO_BIN_DIR:-$HOME/.local/bin}"
SERVICE_NAME="otto"
PLIST_LABEL="com.otto.assistant"
PLIST_FILE="${HOME}/Library/LaunchAgents/${PLIST_LABEL}.plist"
DEFAULT_REPO="MarcoMuellner/otto"
OTTO_HOME=""
TASK_CONFIG_DIR=""
TASK_PROFILE_DIR=""
STATE_DB_PATH=""

BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[0;33m'
RED=$'\033[0;31m'
NC=$'\033[0m'

info() { echo "${BLUE}[ottoctl]${NC} $*"; }
success() { echo "${GREEN}[ottoctl]${NC} $*"; }
warn() { echo "${YELLOW}[ottoctl]${NC} $*"; }
error() { echo "${RED}[ottoctl]${NC} $*" >&2; }

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    error "Required command '$1' not found"
    exit 1
  fi
}

detect_platform() {
  case "$(uname -s)" in
    Linux) echo "linux" ;;
    Darwin) echo "macos" ;;
    *)
      error "Unsupported platform: $(uname -s)"
      exit 1
      ;;
  esac
}

load_install_meta() {
  if [[ -f "${INSTALL_META}" ]]; then
    # shellcheck disable=SC1090
    source "${INSTALL_META}"
  fi
}

resolve_otto_home() {
  local config_path="${HOME}/.config/otto/config.jsonc"

  if [[ -f "${config_path}" ]]; then
    local resolved_home
    resolved_home="$(node -e 'const fs=require("node:fs"); const p=process.argv[1]; try {const raw=fs.readFileSync(p,"utf8"); const parsed=JSON.parse(raw); if (parsed && typeof parsed.ottoHome === "string" && parsed.ottoHome.length > 0) { process.stdout.write(parsed.ottoHome); process.exit(0);} } catch {} process.exit(1)' "${config_path}" 2>/dev/null || true)"
    if [[ -n "${resolved_home}" ]]; then
      echo "${resolved_home}"
      return
    fi
  fi

  echo "${HOME}/.otto"
}

load_telegram_env() {
  if [[ -f "${TELEGRAM_ENV_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${TELEGRAM_ENV_FILE}"
  fi
}

load_runtime_env() {
  if [[ -f "${RUNTIME_ENV_FILE}" ]]; then
    set -a
    # shellcheck disable=SC1090
    source "${RUNTIME_ENV_FILE}"
    set +a
  fi
}

has_telegram_credentials() {
  [[ -n "${TELEGRAM_BOT_TOKEN:-}" ]] && [[ -n "${TELEGRAM_ALLOWED_USER_ID:-}" ]]
}

is_positive_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] && [[ "$1" -ge 1 ]]
}

is_valid_env_key() {
  [[ "$1" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]
}

sql_escape() {
  local value="$1"
  value="${value//\'/\'\'}"
  printf '%s' "${value}"
}

xml_escape() {
  local value="$1"
  value="${value//&/&amp;}"
  value="${value//</&lt;}"
  value="${value//>/&gt;}"
  value="${value//\"/&quot;}"
  value="${value//\'/&apos;}"
  printf '%s' "${value}"
}

ensure_runtime_env_file() {
  mkdir -p "${SECRETS_DIR}"
  chmod 700 "${SECRETS_DIR}"
  touch "${RUNTIME_ENV_FILE}"
  chmod 600 "${RUNTIME_ENV_FILE}"
}

set_runtime_env_value() {
  local key="$1"
  local value="$2"

  ensure_runtime_env_file

  node -e '
const fs = require("node:fs")
const envPath = process.argv[1]
const key = process.argv[2]
const value = process.argv[3]

const lines = fs.existsSync(envPath)
  ? fs.readFileSync(envPath, "utf8").split(/\r?\n/)
  : []

const entries = new Map()

for (const rawLine of lines) {
  const line = rawLine.trim()
  if (!line || line.startsWith("#")) continue
  const idx = line.indexOf("=")
  if (idx <= 0) continue
  const entryKey = line.slice(0, idx).trim()
  const entryValue = line.slice(idx + 1).trim()
  if (!entryKey) continue
  entries.set(entryKey, entryValue)
}

entries.set(key, JSON.stringify(value))

const output = Array.from(entries.entries())
  .sort((a, b) => a[0].localeCompare(b[0]))
  .map(([k, v]) => `${k}=${v}`)
  .join("\n")

fs.writeFileSync(envPath, output.length > 0 ? `${output}\n` : "", "utf8")
' "${RUNTIME_ENV_FILE}" "${key}" "${value}"
}

unset_runtime_env_value() {
  local key="$1"

  ensure_runtime_env_file

  node -e '
const fs = require("node:fs")
const envPath = process.argv[1]
const key = process.argv[2]

const lines = fs.existsSync(envPath)
  ? fs.readFileSync(envPath, "utf8").split(/\r?\n/)
  : []

const entries = new Map()

for (const rawLine of lines) {
  const line = rawLine.trim()
  if (!line || line.startsWith("#")) continue
  const idx = line.indexOf("=")
  if (idx <= 0) continue
  const entryKey = line.slice(0, idx).trim()
  const entryValue = line.slice(idx + 1).trim()
  if (!entryKey) continue
  entries.set(entryKey, entryValue)
}

entries.delete(key)

const output = Array.from(entries.entries())
  .sort((a, b) => a[0].localeCompare(b[0]))
  .map(([k, v]) => `${k}=${v}`)
  .join("\n")

fs.writeFileSync(envPath, output.length > 0 ? `${output}\n` : "", "utf8")
' "${RUNTIME_ENV_FILE}" "${key}"
}

runtime_env_plist_entries() {
  if [[ ! -f "${RUNTIME_ENV_FILE}" ]]; then
    return
  fi

  local keys=()
  while IFS= read -r raw_line; do
    local line="${raw_line%%$'\r'}"
    line="${line#${line%%[![:space:]]*}}"
    [[ -z "${line}" || "${line}" == \#* ]] && continue
    local key="${line%%=*}"
    key="${key%%[[:space:]]*}"
    if [[ -n "${key}" ]] && is_valid_env_key "${key}"; then
      keys+=("${key}")
    fi
  done < "${RUNTIME_ENV_FILE}"

  if [[ ${#keys[@]} -eq 0 ]]; then
    return
  fi

  (
    set -a
    # shellcheck disable=SC1090
    source "${RUNTIME_ENV_FILE}"
    set +a

    local key
    for key in "${keys[@]}"; do
      local value="${!key-}"
      if [[ -n "${value}" ]]; then
        printf '    <key>%s</key>\n    <string>%s</string>\n' "$(xml_escape "${key}")" "$(xml_escape "${value}")"
      fi
    done
  )
}

persist_telegram_credentials() {
  mkdir -p "${SECRETS_DIR}"
  chmod 700 "${SECRETS_DIR}"

cat > "${TELEGRAM_ENV_FILE}" <<EOF
TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
TELEGRAM_ALLOWED_USER_ID=${TELEGRAM_ALLOWED_USER_ID}
EOF

  chmod 600 "${TELEGRAM_ENV_FILE}"
}

prompt_telegram_credentials() {
  if [[ ! -t 0 || ! -t 1 ]]; then
    warn "Telegram credentials missing and terminal is non-interactive; skipping setup"
    return 1
  fi

  while true; do
    info "Telegram credentials are required for automatic Telegram worker startup."
    read -r -p "Configure Telegram now? [Y/n]: " configure_now

    case "${configure_now:-Y}" in
      Y|y|"")
        break
        ;;
      N|n)
        warn "Skipping Telegram credential setup for now"
        return 1
        ;;
      *)
        warn "Please answer Y or n"
        ;;
    esac
  done

  while true; do
    read -r -s -p "TELEGRAM_BOT_TOKEN: " TELEGRAM_BOT_TOKEN
    echo
    read -r -p "TELEGRAM_ALLOWED_USER_ID: " TELEGRAM_ALLOWED_USER_ID

    if [[ -z "${TELEGRAM_BOT_TOKEN}" ]]; then
      warn "TELEGRAM_BOT_TOKEN cannot be empty"
      continue
    fi

    if [[ "${TELEGRAM_BOT_TOKEN}" =~ [[:space:]] ]]; then
      warn "TELEGRAM_BOT_TOKEN cannot contain whitespace"
      continue
    fi

    if ! is_positive_integer "${TELEGRAM_ALLOWED_USER_ID}"; then
      warn "TELEGRAM_ALLOWED_USER_ID must be an integer >= 1"
      continue
    fi

    persist_telegram_credentials
    success "Saved Telegram credentials to ${TELEGRAM_ENV_FILE}"
    return 0
  done
}

ensure_telegram_credentials() {
  load_telegram_env

  if has_telegram_credentials; then
    persist_telegram_credentials
    info "Using existing Telegram credentials"
    return 0
  fi

  if prompt_telegram_credentials; then
    return 0
  fi

  return 1
}

resolve_otto_config_path() {
  echo "${HOME}/.config/otto/config.jsonc"
}

update_telegram_voice_settings() {
  local enabled="$1"
  local command_value="$2"
  local provider_value="${3:-worker}"

  local config_path
  config_path="$(resolve_otto_config_path)"

  node -e '
const fs = require("node:fs")
const path = require("node:path")

const configPath = process.argv[1]
const enabled = process.argv[2] === "1"
const command = process.argv[3] === "" ? null : process.argv[3]
const provider = process.argv[4] === "http" ? "http" : process.argv[4] === "command" ? "command" : "worker"

let parsed = {
  version: 1,
  ottoHome: path.join(process.env.HOME, ".otto"),
  opencode: { hostname: "0.0.0.0", port: 4096 },
}

if (fs.existsSync(configPath)) {
  parsed = JSON.parse(fs.readFileSync(configPath, "utf8"))
}

const telegram = parsed.telegram || {}
const voice = telegram.voice || {}
const transcription = telegram.transcription || {}

parsed.telegram = {
  ...telegram,
  voice: {
    enabled,
    maxDurationSec: Number.isInteger(voice.maxDurationSec) ? voice.maxDurationSec : 180,
    maxBytes: Number.isInteger(voice.maxBytes) ? voice.maxBytes : 10 * 1024 * 1024,
    downloadTimeoutMs: Number.isInteger(voice.downloadTimeoutMs) ? voice.downloadTimeoutMs : 20000,
  },
  transcription: {
    provider,
    timeoutMs: Number.isInteger(transcription.timeoutMs) && transcription.timeoutMs >= 300000 ? transcription.timeoutMs : 300000,
    workerStartupTimeoutMs: Number.isInteger(transcription.workerStartupTimeoutMs) && transcription.workerStartupTimeoutMs >= 600000 ? transcription.workerStartupTimeoutMs : 600000,
    language: typeof transcription.language === "string" && transcription.language.length > 0 ? transcription.language : "en-US",
    model: typeof transcription.model === "string" && transcription.model.length > 0 ? transcription.model : "parakeet-v3",
    command,
    commandArgs: Array.isArray(transcription.commandArgs) && transcription.commandArgs.every((value) => typeof value === "string")
      ? transcription.commandArgs
      : ["{input}"],
    workerScriptPath: typeof transcription.workerScriptPath === "string" && transcription.workerScriptPath.length > 0
      ? transcription.workerScriptPath
      : null,
    workerPythonPath: typeof transcription.workerPythonPath === "string" && transcription.workerPythonPath.length > 0
      ? transcription.workerPythonPath
      : null,
    baseUrl: typeof transcription.baseUrl === "string" && transcription.baseUrl.length > 0
      ? transcription.baseUrl
      : "http://127.0.0.1:9000",
    httpPath: typeof transcription.httpPath === "string" && transcription.httpPath.length > 0
      ? transcription.httpPath
      : "/v1/audio/transcriptions",
  },
}

fs.mkdirSync(path.dirname(configPath), { recursive: true })
fs.writeFileSync(configPath, `${JSON.stringify(parsed, null, 2)}\n`, "utf8")
' "${config_path}" "${enabled}" "${command_value}" "${provider_value}"
}

attempt_auto_provision_parakeet() {

  local install_helper="${CURRENT_LINK}/scripts/install-parakeet-v3.sh"

  if command -v parakeet-v3-transcribe >/dev/null 2>&1; then
    printf '%s' "parakeet-v3-transcribe"
    return 0
  fi

  if command -v parakeet-transcribe >/dev/null 2>&1; then
    printf '%s' "parakeet-transcribe"
    return 0
  fi

  if [[ -x "${install_helper}" ]]; then
    if "${install_helper}"; then
      if command -v parakeet-v3-transcribe >/dev/null 2>&1; then
        printf '%s' "parakeet-v3-transcribe"
        return 0
      fi
      if command -v parakeet-transcribe >/dev/null 2>&1; then
        printf '%s' "parakeet-transcribe"
        return 0
      fi
    fi
  fi

  return 1
}

cmd_configure_voice_transcription() {
  if [[ ! -t 0 || ! -t 1 ]]; then
    info "Voice transcription setup skipped in non-interactive mode"
    return 0
  fi

  local enable_voice=""
  while true; do
    read -r -p "Enable local voice transcription (Parakeet v3) now? [y/N]: " enable_voice
    case "${enable_voice:-N}" in
      Y|y)
        break
        ;;
      N|n|"")
        update_telegram_voice_settings "0" "" "worker"
        info "Voice transcription disabled in settings"
        return 0
        ;;
      *)
        warn "Please answer y or N"
        ;;
    esac
  done

  info "Attempting automatic local Parakeet v3 provisioning..."
  local command_name=""
  if command_name="$(attempt_auto_provision_parakeet)"; then
    update_telegram_voice_settings "1" "${command_name}" "worker"
    success "Voice transcription enabled with persistent worker backend"
    return 0
  fi

  warn "Automatic Parakeet setup is not available in this installation"
  update_telegram_voice_settings "1" "" "worker"
  warn "Voice intake stays enabled, but transcription worker could not be provisioned"
  warn "Telegram voice messages will receive a 'cannot transcribe yet' notice until provisioning succeeds"
}

validate_task_profile_file() {
  local profile_path="$1"

  node -e '
const fs = require("node:fs")
const path = process.argv[1]
const expectedId = process.argv[2] || ""
let parsed
try {
  parsed = JSON.parse(fs.readFileSync(path, "utf8"))
} catch {
  console.error(`Invalid JSON in profile: ${path}`)
  process.exit(1)
}

if (!parsed || parsed.version !== 1) {
  console.error(`Invalid profile version in ${path}`)
  process.exit(1)
}

if (typeof parsed.id !== "string" || parsed.id.trim().length === 0) {
  console.error(`Profile id is required in ${path}`)
  process.exit(1)
}

if (expectedId && parsed.id !== expectedId) {
  console.error(`Profile id mismatch in ${path}: expected ${expectedId}, got ${parsed.id}`)
  process.exit(1)
}

if (parsed.laneOverrides != null && (typeof parsed.laneOverrides !== "object" || Array.isArray(parsed.laneOverrides))) {
  console.error(`laneOverrides must be an object in ${path}`)
  process.exit(1)
}

for (const lane of ["interactive", "scheduled"]) {
  const laneValue = parsed.laneOverrides?.[lane]
  if (laneValue == null) continue
  if (typeof laneValue !== "object" || Array.isArray(laneValue)) {
    console.error(`${lane} override must be an object in ${path}`)
    process.exit(1)
  }
  if (laneValue.opencode == null || typeof laneValue.opencode !== "object" || Array.isArray(laneValue.opencode)) {
    console.error(`${lane}.opencode must be an object in ${path}`)
    process.exit(1)
  }
}
' "${profile_path}" "$2"
}

require_task_runtime_paths() {
  if [[ -z "${TASK_PROFILE_DIR}" || -z "${STATE_DB_PATH}" ]]; then
    error "Task runtime paths are not initialized"
    exit 1
  fi
}

require_state_db() {
  if [[ ! -f "${STATE_DB_PATH}" ]]; then
    error "State database not found: ${STATE_DB_PATH}. Run setup first."
    exit 1
  fi
}

node_print_query_table() {
  local query="$1"
  local params_json="${2:-[]}"

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const query = process.argv[2]
const paramsJson = process.argv[3] ?? "[]"
const params = JSON.parse(paramsJson)

const db = new DatabaseSync(dbPath)
try {
  const rows = db.prepare(query).all(...params)
  if (!rows.length) {
    console.log("(no rows)")
    process.exit(0)
  }

  const columns = Object.keys(rows[0])
  console.log(columns.join("\t"))
  for (const row of rows) {
    const line = columns
      .map((column) => {
        const value = row[column]
        return value == null ? "" : String(value).replaceAll("\n", "\\n")
      })
      .join("\t")
    console.log(line)
  }
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${query}" "${params_json}"
}

node_print_tasks_table() {
  local maybe_task_id="${1:-}"

  node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const taskId = process.argv[2] ?? ""
const db = new DatabaseSync(dbPath)

const printRows = (rows) => {
  if (!rows.length) {
    console.log("(no rows)")
    return
  }

  const columns = [
    "id",
    "type",
    "schedule_type",
    "profile_id",
    "status",
    "next_run_at",
    "terminal_state",
  ]
  console.log(columns.join("\t"))
  for (const row of rows) {
    console.log(columns.map((col) => (row[col] == null ? "" : String(row[col]))).join("\t"))
  }
}

try {
  const columns = new Set(db.prepare("PRAGMA table_info(jobs)").all().map((row) => row.name))
  const has = (column) => columns.has(column)
  const selectExpr = [
    "id",
    "type",
    has("schedule_type") ? "schedule_type" : "NULL AS schedule_type",
    has("profile_id") ? "profile_id" : "NULL AS profile_id",
    "status",
    has("next_run_at") ? "next_run_at" : "NULL AS next_run_at",
    has("terminal_state") ? "terminal_state" : "NULL AS terminal_state",
  ].join(", ")

  if (taskId) {
    const rows = db.prepare(`SELECT ${selectExpr} FROM jobs WHERE id = ?`).all(taskId)
    printRows(rows)
    process.exit(0)
  }

  const rows = db.prepare(`SELECT ${selectExpr} FROM jobs ORDER BY id ASC`).all()
  printRows(rows)
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${maybe_task_id}"
}

cmd_task_profiles_list() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local found=0
  while IFS= read -r profile_path; do
    found=1
    node -e 'const fs=require("node:fs"); const p=process.argv[1]; try {const obj=JSON.parse(fs.readFileSync(p,"utf8")); process.stdout.write(`${obj.id || "<invalid-id>"}\t${p}\n`)} catch {process.stdout.write(`<invalid>\t${p}\n`)}' "${profile_path}"
  done < <(find "${TASK_PROFILE_DIR}" -maxdepth 1 -type f -name "*.jsonc" -print 2>/dev/null | sort)

  if [[ ${found} -eq 0 ]]; then
    info "No task profiles installed in ${TASK_PROFILE_DIR}"
  fi
}

cmd_task_profiles_validate() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local profile_id="${1:-}"
  if [[ -z "${profile_id}" ]]; then
    local any=0
    while IFS= read -r profile_path; do
      any=1
      local filename expected_id
      filename="$(basename "${profile_path}")"
      expected_id="${filename%.jsonc}"
      validate_task_profile_file "${profile_path}" "${expected_id}"
      success "Valid: ${expected_id}"
    done < <(find "${TASK_PROFILE_DIR}" -maxdepth 1 -type f -name "*.jsonc" -print 2>/dev/null | sort)

    if [[ ${any} -eq 0 ]]; then
      warn "No profiles found to validate in ${TASK_PROFILE_DIR}"
    fi
    return
  fi

  local profile_path="${TASK_PROFILE_DIR}/${profile_id}.jsonc"
  if [[ ! -f "${profile_path}" ]]; then
    error "Profile not found: ${profile_id}"
    exit 1
  fi

  validate_task_profile_file "${profile_path}" "${profile_id}"
  success "Valid: ${profile_id}"
}

cmd_task_profiles_install() {
  require_task_runtime_paths
  mkdir -p "${TASK_PROFILE_DIR}"

  local source_path="${1:-}"
  if [[ -z "${source_path}" ]]; then
    error "Usage: ottoctl task profiles install <profile-file.jsonc>"
    exit 1
  fi

  if [[ ! -f "${source_path}" ]]; then
    error "Profile file not found: ${source_path}"
    exit 1
  fi

  local filename expected_id target_path
  filename="$(basename "${source_path}")"
  expected_id="${filename%.jsonc}"
  target_path="${TASK_PROFILE_DIR}/${filename}"

  validate_task_profile_file "${source_path}" "${expected_id}"
  cp "${source_path}" "${target_path}"
  chmod 600 "${target_path}" || true

  success "Installed task profile: ${expected_id}"
}

cmd_task_bind_profile() {
  require_task_runtime_paths
  require_state_db

  local task_id="${1:-}"
  local profile_id="${2:-}"

  if [[ -z "${task_id}" || -z "${profile_id}" ]]; then
    error "Usage: ottoctl task bind-profile <task-id> <profile-id>"
    exit 1
  fi

  local profile_path="${TASK_PROFILE_DIR}/${profile_id}.jsonc"
  if [[ ! -f "${profile_path}" ]]; then
    error "Profile not found: ${profile_id}"
    exit 1
  fi

  validate_task_profile_file "${profile_path}" "${profile_id}"

  if node -e '
const { DatabaseSync } = require("node:sqlite")

const dbPath = process.argv[1]
const taskId = process.argv[2]
const profileId = process.argv[3]
const now = Date.now()

const db = new DatabaseSync(dbPath)
try {
  const columns = new Set(db.prepare("PRAGMA table_info(jobs)").all().map((row) => row.name))
  if (!columns.has("profile_id")) {
    process.exit(3)
  }

  const result = db
    .prepare("UPDATE jobs SET profile_id = ?, updated_at = ? WHERE id = ?")
    .run(profileId, now, taskId)

  if ((result.changes ?? 0) < 1) {
    process.exit(2)
  }
} finally {
  db.close()
}
' "${STATE_DB_PATH}" "${task_id}" "${profile_id}"
  then
    :
  else
    local update_status=$?
    if [[ ${update_status} -eq 2 ]]; then
      error "Task not found: ${task_id}"
      exit 1
    fi
    if [[ ${update_status} -eq 3 ]]; then
      error "Current state database does not support profile bindings yet. Run ottoctl update/setup first."
      exit 1
    fi
    exit ${update_status}
  fi

  success "Bound task ${task_id} to profile ${profile_id}"
}

cmd_task_show() {
  require_task_runtime_paths
  require_state_db

  local task_id="${1:-}"
  if [[ -z "${task_id}" ]]; then
    error "Usage: ottoctl task show <task-id>"
    exit 1
  fi

  node_print_tasks_table "${task_id}"
}

cmd_task_list() {
  require_task_runtime_paths
  require_state_db

  node_print_tasks_table
}

cmd_task_audit() {
  require_task_runtime_paths
  require_state_db

  local limit="${1:-50}"
  if ! [[ "${limit}" =~ ^[0-9]+$ ]] || [[ "${limit}" -lt 1 ]] || [[ "${limit}" -gt 200 ]]; then
    error "Usage: ottoctl task audit [limit:1-200]"
    exit 1
  fi

  info "Recent task audit records (limit=${limit})"
  node_print_query_table \
    "SELECT id, task_id, action, lane, actor, created_at FROM task_audit_log ORDER BY created_at DESC LIMIT ?" \
    "[${limit}]"
  echo
  info "Recent command audit records (limit=${limit})"
  node_print_query_table \
    "SELECT id, command, lane, status, error_message, created_at FROM command_audit_log ORDER BY created_at DESC LIMIT ?" \
    "[${limit}]"
}

cmd_task() {
  local subcommand="${1:-}"
  shift || true

  case "${subcommand}" in
    profiles)
      local profile_action="${1:-list}"
      shift || true
      case "${profile_action}" in
        list)
          cmd_task_profiles_list "$@"
          ;;
        validate)
          cmd_task_profiles_validate "$@"
          ;;
        install)
          cmd_task_profiles_install "$@"
          ;;
        *)
          error "Unknown task profiles command: ${profile_action}"
          exit 1
          ;;
      esac
      ;;
    bind-profile)
      cmd_task_bind_profile "$@"
      ;;
    list)
      cmd_task_list "$@"
      ;;
    show)
      cmd_task_show "$@"
      ;;
    audit)
      cmd_task_audit "$@"
      ;;
    *)
      error "Unknown task command: ${subcommand}"
      exit 1
      ;;
  esac
}

run_extension_cli() {
  NODE_ENV=production OTTO_HOME="${OTTO_HOME}" node "${CURRENT_LINK}/dist/extension-cli.mjs" "$@"
}

cmd_extension() {
  local subcommand="${1:-}"
  shift || true

  case "${subcommand}" in
    list)
      run_extension_cli list "$@"
      ;;
    install)
      run_extension_cli install "$@"
      ;;
    update)
      run_extension_cli update "$@"
      ;;
    disable)
      run_extension_cli disable "$@"
      ;;
    remove)
      run_extension_cli remove "$@"
      ;;
    help|--help|-h|"")
      run_extension_cli --help
      ;;
    *)
      error "Unknown extension command: ${subcommand}"
      exit 1
      ;;
  esac
}

cmd_env_path() {
  echo "${RUNTIME_ENV_FILE}"
}

cmd_env_list() {
  ensure_runtime_env_file
  info "Runtime environment file: ${RUNTIME_ENV_FILE}"
  if [[ ! -s "${RUNTIME_ENV_FILE}" ]]; then
    echo "(empty)"
    return
  fi

  cat "${RUNTIME_ENV_FILE}"
}

cmd_env_set() {
  local key="${1:-}"
  local value="${2:-}"

  if [[ -z "${key}" || -z "${value}" ]]; then
    error "Usage: ottoctl env set <KEY> <VALUE>"
    exit 1
  fi

  if ! is_valid_env_key "${key}"; then
    error "Invalid environment variable key: ${key}"
    exit 1
  fi

  set_runtime_env_value "${key}" "${value}"
  success "Saved ${key} to ${RUNTIME_ENV_FILE}"
  info "Run: ottoctl restart (or ottoctl stop && ottoctl start) to apply"
}

cmd_env_unset() {
  local key="${1:-}"

  if [[ -z "${key}" ]]; then
    error "Usage: ottoctl env unset <KEY>"
    exit 1
  fi

  if ! is_valid_env_key "${key}"; then
    error "Invalid environment variable key: ${key}"
    exit 1
  fi

  unset_runtime_env_value "${key}"
  success "Removed ${key} from ${RUNTIME_ENV_FILE}"
  info "Run: ottoctl restart (or ottoctl stop && ottoctl start) to apply"
}

cmd_env() {
  local subcommand="${1:-list}"
  shift || true

  case "${subcommand}" in
    list)
      cmd_env_list "$@"
      ;;
    path)
      cmd_env_path "$@"
      ;;
    set)
      cmd_env_set "$@"
      ;;
    unset)
      cmd_env_unset "$@"
      ;;
    *)
      error "Unknown env command: ${subcommand}"
      exit 1
      ;;
  esac
}

resolve_repo() {
  local explicit_repo="${1:-}"
  if [[ -n "${explicit_repo}" ]]; then
    echo "${explicit_repo}"
    return
  fi

  if [[ -n "${OTTO_GITHUB_REPO:-}" ]]; then
    echo "${OTTO_GITHUB_REPO}"
    return
  fi

  echo "${DEFAULT_REPO}"
}

fetch_release_info() {
  local repo="$1"
  local channel="$2"

  node "${CURRENT_LINK}/scripts/resolve-release.mjs" "${repo}" "${channel}"
}

install_release() {
  local tag="$1"
  local artifact_url="$2"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap '[[ -n "${tmp_dir:-}" ]] && rm -rf "${tmp_dir}"' RETURN

  mkdir -p "${RELEASES_DIR}" "${BIN_DIR}"

  info "Downloading ${tag}..."
  curl -fsSL "${artifact_url}" -o "${tmp_dir}/otto.tgz"

  local release_dir="${RELEASES_DIR}/${tag}"
  rm -rf "${release_dir}"
  mkdir -p "${release_dir}"
  tar -xzf "${tmp_dir}/otto.tgz" -C "${release_dir}"

  ln -sfn "${release_dir}" "${CURRENT_LINK}"

  if [[ -f "${CURRENT_LINK}/bin/ottoctl" ]]; then
    local target_cli="${BIN_DIR}/ottoctl"
    local staged_cli="${BIN_DIR}/.ottoctl.$$"

    cp "${CURRENT_LINK}/bin/ottoctl" "${staged_cli}"
    chmod +x "${staged_cli}"
    mv -f "${staged_cli}" "${target_cli}"
    chmod +x "${BIN_DIR}/ottoctl"
  fi

  success "Installed ${tag}"
}

run_setup() {
  require_cmd node
  NODE_ENV=production node "${CURRENT_LINK}/dist/index.mjs" setup
}

install_service_linux() {
  local node_path
  node_path="$(command -v node)"
  local user_dir="${HOME}/.config/systemd/user"
  local service_file="${user_dir}/${SERVICE_NAME}.service"

  mkdir -p "${user_dir}"

  cat > "${service_file}" <<EOF
[Unit]
Description=Otto Personal Assistant
After=network.target

[Service]
Type=simple
ExecStart=${node_path} ${CURRENT_LINK}/dist/index.mjs serve
WorkingDirectory=${HOME}
Restart=on-failure
RestartSec=5
EnvironmentFile=-${RUNTIME_ENV_FILE}
Environment=HOME=${HOME}
Environment=PATH=${PATH}
Environment=NODE_ENV=production
StandardOutput=journal
StandardError=journal
SyslogIdentifier=otto

[Install]
WantedBy=default.target
EOF

  systemctl --user daemon-reload
  systemctl --user enable "${SERVICE_NAME}" >/dev/null

  if command -v loginctl >/dev/null 2>&1; then
    loginctl enable-linger "$(whoami)" >/dev/null 2>&1 || true
  fi
}

install_service_macos() {
  local node_path
  node_path="$(command -v node)"
  local runtime_env_keys=""
  runtime_env_keys="$(runtime_env_plist_entries)"

  mkdir -p "${HOME}/Library/LaunchAgents"

  cat > "${PLIST_FILE}" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>${PLIST_LABEL}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${node_path}</string>
    <string>${CURRENT_LINK}/dist/index.mjs</string>
    <string>serve</string>
  </array>
  <key>WorkingDirectory</key>
  <string>${HOME}</string>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>EnvironmentVariables</key>
  <dict>
    <key>HOME</key>
    <string>${HOME}</string>
    <key>PATH</key>
    <string>${PATH}</string>
    <key>NODE_ENV</key>
    <string>production</string>
${runtime_env_keys}
  </dict>
  <key>StandardOutPath</key>
  <string>${HOME}/.local/share/otto/logs/service.log</string>
  <key>StandardErrorPath</key>
  <string>${HOME}/.local/share/otto/logs/service.err.log</string>
</dict>
</plist>
EOF
}

install_service() {
  local platform
  platform="$(detect_platform)"

  mkdir -p "${OTTO_ROOT}/logs"

  if [[ "${platform}" == "linux" ]]; then
    install_service_linux
  else
    install_service_macos
  fi
}

start_service() {
  local platform
  platform="$(detect_platform)"

  if [[ "${platform}" == "linux" ]]; then
    systemctl --user start "${SERVICE_NAME}"
  else
    launchctl bootout "gui/$(id -u)" "${PLIST_FILE}" >/dev/null 2>&1 || true
    launchctl bootstrap "gui/$(id -u)" "${PLIST_FILE}"
    launchctl kickstart -k "gui/$(id -u)/${PLIST_LABEL}"
  fi
}

stop_service() {
  local platform
  platform="$(detect_platform)"

  if [[ "${platform}" == "linux" ]]; then
    systemctl --user stop "${SERVICE_NAME}"
  else
    launchctl bootout "gui/$(id -u)" "${PLIST_FILE}" >/dev/null 2>&1 || true
  fi
}

restart_service() {
  stop_service || true
  start_service
}

write_install_meta() {
  local repo="$1"
  mkdir -p "${OTTO_ROOT}"
  cat > "${INSTALL_META}" <<EOF
OTTO_GITHUB_REPO=${repo}
OTTO_ROOT=${OTTO_ROOT}
OTTO_BIN_DIR=${BIN_DIR}
EOF
}

cmd_update() {
  local channel="stable"
  local repo_override=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --nightly)
        channel="nightly"
        shift
        ;;
      --repo)
        repo_override="${2:-}"
        shift 2
        ;;
      *)
        error "Unknown option for update: $1"
        exit 1
        ;;
    esac
  done

  local repo
  repo="$(resolve_repo "${repo_override}")"

  local release_info
  release_info="$(fetch_release_info "${repo}" "${channel}")"
  local tag artifact_url artifact_name
  tag="$(printf '%s\n' "${release_info}" | sed -n '1p')"
  artifact_url="$(printf '%s\n' "${release_info}" | sed -n '2p')"
  artifact_name="$(printf '%s\n' "${release_info}" | sed -n '3p')"

  info "Using artifact ${artifact_name} (${tag})"

  install_release "${tag}" "${artifact_url}"
  write_install_meta "${repo}"
  run_setup
  ensure_telegram_credentials || true
  cmd_configure_voice_transcription || true
  install_service
  restart_service

  success "Otto updated to ${tag}"
}

cmd_start() {
  install_service
  start_service
  success "Otto service started"
}

cmd_restart() {
  install_service
  restart_service
  success "Otto service restarted"
}

cmd_stop() {
  stop_service
  success "Otto service stopped"
}

cmd_configure_telegram() {
  if ensure_telegram_credentials; then
    success "Telegram credential setup complete"
  else
    warn "Telegram credential setup skipped"
  fi
}

cmd_help() {
  cat <<'EOF'
ottoctl - Otto server control

Usage:
  ottoctl start
  ottoctl restart
  ottoctl stop
  ottoctl configure-telegram
  ottoctl configure-voice-transcription
  ottoctl env list
  ottoctl env path
  ottoctl env set <KEY> <VALUE>
  ottoctl env unset <KEY>
  ottoctl task profiles list
  ottoctl task profiles validate [profile-id]
  ottoctl task profiles install <profile-file.jsonc>
  ottoctl task list
  ottoctl task bind-profile <task-id> <profile-id>
  ottoctl task show <task-id>
  ottoctl task audit [limit]
  ottoctl extension list
  ottoctl extension install <id>[@version]
  ottoctl extension update <id>
  ottoctl extension update --all
  ottoctl extension disable <id>
  ottoctl extension remove <id>[@version]
  ottoctl update [--nightly] [--repo owner/repo]
EOF
}

main() {
  require_cmd curl
  require_cmd tar
  require_cmd node

  load_install_meta
  load_telegram_env
  load_runtime_env
  OTTO_HOME="$(resolve_otto_home)"
  TASK_CONFIG_DIR="${OTTO_HOME}/task-config"
  TASK_PROFILE_DIR="${TASK_CONFIG_DIR}/profiles"
  STATE_DB_PATH="${OTTO_HOME}/data/otto-state.db"

  case "${1:-help}" in
    start)
      shift
      cmd_start "$@"
      ;;
    stop)
      shift
      cmd_stop "$@"
      ;;
    restart)
      shift
      cmd_restart "$@"
      ;;
    configure-telegram)
      shift
      cmd_configure_telegram "$@"
      ;;
    configure-voice-transcription)
      shift
      cmd_configure_voice_transcription "$@"
      ;;
    task)
      shift
      cmd_task "$@"
      ;;
    extension)
      shift
      cmd_extension "$@"
      ;;
    env)
      shift
      cmd_env "$@"
      ;;
    update)
      shift
      cmd_update "$@"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      error "Unknown command: $1"
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
